/*
 * Note for accuracy reasons all latitude & longitudes will be in degrees 
 */

class DuneTask {
    float entry_latitude, entry_longitude;
    float exit_latitude, exit_longitude;
    float distance;	
	
    DuneTask(float lat_i, float lon_i, float lat_e, float lon_e, float d) {
		entry_latitude = lat_i;
		entry_longitude = lon_i;
		exit_latitude = lat_e;
		exit_longitude = lon_e;
		distance = d;
    }
};

class Position extends Timeline {
    predicate Pos {
		float latitude, longitude, depth;
		bool  from_task;
		duration == 1;
    }	 		
};

class SpeedControl extends Timeline {
	float min_speed, nominal_speed, max_speed;
	int min_bat, nominal_bat, max_bat;

    predicate Holds {
		float speed;
		speed > 0.0;
    }

	SpeedControl(float _mi_s, int _mi_b, float _nom_s, int _nom_b, float _ma_s, int _ma_b) {
		min_speed     = _mi_s;
		nominal_speed = _nom_s;
		max_speed     = _ma_s;
		min_bat     = _mi_b;
		nominal_bat = _nom_b;
		max_bat     = _ma_b;
	}
}

SpeedControl::Holds {	
	start >= 0;
	start+duration == end;
	end <= object.min_bat;
	
	object.min_speed <= speed;
	speed <= object.max_speed;
}

class AuvActions extends Timeline {

    action Transit {
    	float distance;
    	float speed;
    	start >= 0;
    }
    action ExecTask {
     	float dur_secs;
     	start >= 0;
    }

    AuvActions() {}

};

class Auv extends Timeline {
    Position position;
    SpeedControl ctrl;
    AuvActions    my_actions;
    
	
    predicate Execute {
		DuneTask task;
		float speed, distance, min_dist;
		start >= 0;
    }
	
    Auv() {
		position = new Position();
		// Default values for an Auv taken using some rule of thumb with no real justification
		ctrl = new SpeedControl(0.5, 72000, 1.1, 36000, 1.5, 25200);
		my_actions = new AuvActions();
    }
    Auv(float _min_s, int _min_b, float _nom_s, int _nom_b, float _max_s, int _max_b) {
		position = new Position();
		ctrl = new SpeedControl(_min_s, _min_b, _nom_s, _nom_b, _max_s, _max_b);
		my_actions = new AuvActions();
    }
};

Auv::Execute {
	contained_by(SpeedControl.Holds sp);
	sp.object == object.ctrl;
	speed == sp.speed;
	
	distance == task.distance;
	ll_dist(task.entry_latitude, task.entry_longitude,
			task.exit_latitude, task.exit_longitude) <= distance;
}

AuvActions::Transit {
	Auv me;
	me.my_actions == object;
	
	meets(effect Position.Pos dest);
	dest.object == me.position;
	dest.from_task == false;
	
	starts(condition Position.Pos source);
	source.object == me.position;
	
	distance == ll_dist(source.latitude, source.longitude, 
						dest.latitude, dest.longitude);
						
	contained_by(SpeedControl.Holds sp);
	sp.object == me.ctrl;
	speed == sp.speed;

	float dur_secs;
	// compute the duration taking into account rounding error
	(dur_secs + 1.0) * speed == distance;
	
	duration >= dur_secs;
	start+duration == end;
}

AuvActions::ExecTask {
	Auv me;
	DuneTask task;
	
	equals(effect Auv.Execute exec);
	task == exec.task;
	me == exec.object;
	
	meets(effect Position.Pos dest);
	dest.object == me.position;
	dest.from_task == true;
	dest.latitude == task.exit_latitude;
	dest.longitude == task.exit_longitude;
	
	
	starts(condition Position.Pos source);
	source.object == me.position;
	source.latitude == task.entry_latitude;
	source.longitude == task.entry_longitude;
	
	// compute the duration taking into account rounding error
	(dur_secs + 1.0) * exec.speed == exec.distance;
	
	duration >= dur_secs;
	start+duration == end;
}


