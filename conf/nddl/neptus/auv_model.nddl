/*
 * Note for accuracy reasons all latitude & longitudes will be in degrees 
 */

class DuneTask {
    float entry_latitude, entry_longitude;
    float exit_latitude, exit_longitude;
    float distance;	
	
    DuneTask(float lat_i, float lon_i, float lat_e, float lon_e, float d) {
	entry_latitude = lat_i;
	entry_longitude = lon_i;
	exit_latitude = lat_e;
	exit_longitude = lon_e;
	distance = d;
    }
};

class Position extends Timeline {
    predicate Pos {
	float latitude, longitude, depth;
	bool  from_task;
	//duration == 1;
    }	 		
};

Position::Pos {
    //if( start==0 ) {
	//duration == 1; 
    //}	
}

class Battery extends Reservoir {
    string profileType;
    string detectorType;

    Battery(float ic, float ll_min, float ll_max) {
	super(ic, ll_min, ll_max);
	profileType = "IncrementalFlowProfile";
	detectorType = "ClosedWorldFVDetector";
        //profileType = "GroundedProfile";
        //detectorType = "GroundedFVDetector";
    }
}

class SpeedControl extends Timeline {
    Battery battery;
	
    float min_speed, nominal_speed, max_speed;
    int min_bat, nominal_bat, max_bat;

    predicate Holds {
	float speed, speed_bat;
	speed > 0.0;
    }

    SpeedControl(float _mi_s, int _mi_b, float _nom_s, int _nom_b, float _ma_s, int _ma_b) {
	min_speed     = _mi_s;
	nominal_speed = _nom_s;
	max_speed     = _ma_s;
	min_bat     = _mi_b;
	nominal_bat = _nom_b;
	max_bat     = _ma_b;
	// My battery has 1000 units
	battery = new Battery(1000.0, 0.0, 1000.0);
    }
}

SpeedControl::Holds {	
    start >= 0;
    start+duration == end;
    end <= object.min_bat; // this line is useless now that we compute the profile
	
    object.min_speed <= speed;
    speed <= object.max_speed;
		
    // square_fact * speed^2 + lin_fact * speed + padding == battery
    // I need to identify the factors from the 3 points I have
    // Most of the lines below do define how to resolve this "simple"
    // equation with 3 unknowns
    float square_fact, lin_fact, padding;
    float min_sp_2, nom_sp_2, max_sp_2, speed_2;
	
    object.min_speed == sqrt(min_sp_2);
    object.nominal_speed == sqrt(nom_sp_2);
    object.max_speed == sqrt(max_sp_2);
    speed == sqrt(speed_2);
	
    float min_b, nom_b, max_b;
    min_b == to_float(object.min_bat);
    nom_b == to_float(object.nominal_bat);
    max_b == to_float(object.max_bat);
	
    float a_1_2, a_2_3, b_1_2, b_2_3, c_1_2,c_2_3;
	
    nom_sp_2 + a_1_2 == max_sp_2;
    object.nominal_speed + b_1_2 == object.max_speed;
    nom_b + c_1_2 == max_b;
	
    min_sp_2 + a_2_3 == nom_sp_2;
    object.min_speed + b_2_3 == object.nominal_speed;
    min_b + c_2_3 == nom_b;

    float norm_b, a, c;
	
    a + (a_2_3 * b_1_2) == a_1_2 * b_2_3;
    c + (c_2_3 * b_1_2) == c_2_3 * b_2_3;
	
    // All t his mees is to end up to these 3  finals equations that 
    // compute the quadratic representation of my battery profile in 
    // relation to vehicle speed
    square_fact * a == c;
    (square_fact * a_1_2) + (lin_fact * b_1_2) == c_1_2;
    (square_fact * min_sp_2) + (lin_fact * object.min_speed) + padding == min_b;
	   	   
	   
    // based on this I can compute Waht is my battery duration for the given speed
    (square_fact * speed_2) + (lin_fact * speed) + padding == speed_bat;
}

class AuvActions extends Timeline {

    action Transit {
    	float distance;
    	float speed;
    	start >= 0;
    }
    action ExecTask {
     	float dur_secs;
     	start >= 0;
    }

    AuvActions() {}

};

class Auv extends Timeline {
    Position position;
    SpeedControl ctrl;
    AuvActions    my_actions;
    
	
    predicate Execute {
	DuneTask task;
	float speed, distance, min_dist;
	int id;
	int idleTime;
	start >= 0;
	idleTime >= 0;
    }
    
    predicate Transit {
    	float speed;
    }
	
    Auv() {
	position = new Position();
	// Default values for an Auv taken using some rule of thumb with no real justification
	ctrl = new SpeedControl(0.5, 72000, 1.1, 36000, 1.5, 25200);
	my_actions = new AuvActions();
    }
    Auv(float _min_s, int _min_b, float _nom_s, int _nom_b, float _max_s, int _max_b) {
	position = new Position();
	ctrl = new SpeedControl(_min_s, _min_b, _nom_s, _nom_b, _max_s, _max_b);
	my_actions = new AuvActions();
    }
};

Auv::Execute {
    contained_by(SpeedControl.Holds sp);
    sp.object == object.ctrl;
    speed == sp.speed;
    start + duration == end;
    idleTime <= duration; 
    distance == task.distance;
    ll_dist(task.entry_latitude, task.entry_longitude,
	    task.exit_latitude, task.exit_longitude) <= distance;
    // Ideally I should  consume the idle time here but I won't for now 
    // unless the idleTime is already bounded    
    if( 2.0*to_float(idleTime) <= sp.speed_bat ) {
     	Battery batt;
    	batt == sp.object.battery;
 
    	float consumption;
    	consumption * sp.speed_bat == to_float(idleTime) * 1000.0;
    	consumption >= 0.0;
    	consumption <= 1000.0;

    	starts(effect batt.consume tx);
    	tx.quantity == consumption;
    } 
}

AuvActions::Transit {
    Auv me;
    me.my_actions == object;
	
	equals(effect me.Transit t);
		t.speed == speed;
		
    meets(effect Position.Pos dest);
    dest.object == me.position;
    dest.from_task == false;
	dest.duration == 1;
    starts_during(condition Position.Pos source);
    source.object == me.position;
    temporalDistance(start, 1, source.end); 
	
	
    distance == ll_dist(source.latitude, source.longitude, 
			dest.latitude, dest.longitude);
						
    contained_by(SpeedControl.Holds sp);
    sp.object == me.ctrl;
    speed == sp.speed;
	
    float dur_secs;
    // compute the duration taking into account rounding error
    (dur_secs + 1.0) * speed == distance;
    duration >= dur_secs;
    2.0 * dur_secs + 100.0 >= duration; 
    start+duration == end;

    Battery batt;
    batt == sp.object.battery;

    float consumption;
    consumption * sp.speed_bat == to_float(duration) * 1000.0;
    consumption >= 0.0;
    consumption <= 1000.0;

    starts(effect batt.consume tx);
    tx.quantity == consumption;
}

AuvActions::ExecTask {
    Auv me;
    DuneTask task;
    me.my_actions == object;
	
    starts(effect Auv.Execute exec);
    task == exec.task;
    end + exec.idleTime <= exec.end;
    me == exec.object;
	
    meets(effect Position.Pos dest);
    dest.object == me.position;
    dest.from_task == true;
    dest.latitude == task.exit_latitude;
    dest.longitude == task.exit_longitude;
   	// exec ends_after_start dest; 
	temporalDistance(exec.end, 1, dest.end);
	
    starts_during(condition Position.Pos source);
    source.object == me.position;
    temporalDistance(start, 1, source.end); 
    source.latitude == task.entry_latitude;
    source.longitude == task.entry_longitude;
	
    // compute the duration taking into account rounding error
    (dur_secs + 1.0) * exec.speed == exec.distance;
	
    duration >= dur_secs;
    2.0 * dur_secs + 100.0 >= duration; 
    start+duration == end;
    
    contained_by(condition SpeedControl.Holds sp);
    sp.object == me.ctrl;
    Battery batt;
    batt == sp.object.battery;
 
    float consumption;
    consumption * sp.speed_bat == to_float(duration) * 1000.0;
    consumption >= 0.0;
    consumption <= 1000.0;

    starts(effect batt.consume tx);
    tx.quantity == consumption;
}


