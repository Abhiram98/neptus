/*
 * Note for accuracy reasons all latitude & longitudes will be in degrees 
 */

class DuneTask {
    float entry_latitude, entry_longitude;
    float exit_latitude, exit_longitude;
    float distance;	
	
    DuneTask(float lat_i, float lon_i, float lat_e, float lon_e, float d) {
		entry_latitude = lat_i;
		entry_longitude = lon_i;
		exit_latitude = lat_e;
		exit_longitude = lon_e;
		distance = d;
    }
};

class Position extends Timeline {
    predicate Pos {
		float latitude, longitude, depth;
		bool  from_task;
		duration == 1;
    }	 		
};

class SpeedControl extends Timeline {
	float min_speed, nominal_speed, max_speed;
	int min_bat, nominal_bat, max_bat;

    predicate Holds {
		float speed, bat_ratio;
		speed > 0.0;
		bat_ratio > 0.0;
    }

	SpeedControl(float _mi_s, int _mi_b, float _nom_s, int _nom_b, float _ma_s, int _ma_b) {
		min_speed     = _mi_s;
		nominal_speed = _nom_s;
		max_speed     = _ma_s;
		min_bat     = _mi_b;
		nominal_bat = _nom_b;
		max_bat     = _ma_b;
	}
}

SpeedControl::Holds {	
	start >= 0;
	start+duration == end;
	end <= object.min_bat;
	
	object.min_speed <= speed;
	speed <= object.max_speed;
		
	// square_fact * speed^2 + lin_fact * speed + padding == battery
	// I need to identify the factors from the 3 points I have
	// Most of the lines below do define how to resolve this "simple"
	// equation with 3 unknowns
	float square_fact, lin_fact, padding;
	float min_sp_2, nom_sp_2, max_sp_2, speed_2;
	
	object.min_speed == sqrt(min_sp_2);
	object.nominal_speed == sqrt(nom_sp_2);
	object.max_speed == sqrt(max_sp_2);
	speed == sqrt(speed_2);
	
	float min_b, nom_b, max_b;
	min_b == to_float(object.min_bat);
	nom_b == to_float(object.nominal_bat);
	max_b == to_float(object.max_bat);
	
	float a_1_2, a_2_3, b_1_2, b_2_3, c_1_2,c_2_3;
	
	nom_sp_2 + a_1_2 == max_sp_2;
	object.nominal_speed + b_1_2 == object.max_speed;
	nom_b + c_1_2 == max_b;
	
	min_sp_2 + a_2_3 == nom_sp_2;
	object.min_speed + b_2_3 == object.nominal_speed;
	min_b + c_2_3 == nom_b;

	float norm_b, a, c;
	
	a + (a_2_3 * b_1_2) == a_1_2 * b_2_3;
	c + (c_2_3 * b_1_2) == c_2_3 * b_2_3;
	
	// All t his mees is to end up to these 3  finals equations that 
	// compute the quadratic representation of my battery profile in 
	// relation to vehicle speed
	square_fact * a == c;
	(square_fact * a_1_2) + (lin_fact * b_1_2) == c_1_2;
	(square_fact * min_sp_2) + (lin_fact * object.min_speed) + padding == min_b;
	   	   
	   
	float my_b;
	// based on this I can compute Waht is my battery duration for the given speed
	(square_fact * speed_2) + (lin_fact * speed) + padding == my_b;
	bat_ratio * min_b == my_b; 
	
	// bat_ratio tells me how much of the resource is used per tick relative to 
	// the best possible choice I can now apply this value to compute how much  
	// of the battery I will use based on the tasks duration
	
}

class AuvActions extends Timeline {

    action Transit {
    	float distance;
    	float speed;
    	start >= 0;
    }
    action ExecTask {
     	float dur_secs;
     	start >= 0;
    }

    AuvActions() {}

};

class Auv extends Timeline {
    Position position;
    SpeedControl ctrl;
    AuvActions    my_actions;
    
	
    predicate Execute {
		DuneTask task;
		float speed, distance, min_dist;
		int id;
		start >= 0;
    }
	
    Auv() {
		position = new Position();
		// Default values for an Auv taken using some rule of thumb with no real justification
		ctrl = new SpeedControl(0.5, 72000, 1.1, 36000, 1.5, 25200);
		my_actions = new AuvActions();
    }
    Auv(float _min_s, int _min_b, float _nom_s, int _nom_b, float _max_s, int _max_b) {
		position = new Position();
		ctrl = new SpeedControl(_min_s, _min_b, _nom_s, _nom_b, _max_s, _max_b);
		my_actions = new AuvActions();
    }
};

Auv::Execute {
	contained_by(SpeedControl.Holds sp);
	sp.object == object.ctrl;
	speed == sp.speed;
	
	distance == task.distance;
	ll_dist(task.entry_latitude, task.entry_longitude,
			task.exit_latitude, task.exit_longitude) <= distance;
}

AuvActions::Transit {
	Auv me;
	me.my_actions == object;
	
	meets(effect Position.Pos dest);
	dest.object == me.position;
	dest.from_task == false;
	
	starts(condition Position.Pos source);
	source.object == me.position;
	
	distance == ll_dist(source.latitude, source.longitude, 
						dest.latitude, dest.longitude);
						
	contained_by(SpeedControl.Holds sp);
	sp.object == me.ctrl;
	speed == sp.speed;

	float dur_secs;
	// compute the duration taking into account rounding error
	(dur_secs + 1.0) * speed == distance;
	
	duration >= dur_secs;
	start+duration == end;
}

AuvActions::ExecTask {
	Auv me;
	DuneTask task;
	
	equals(effect Auv.Execute exec);
	task == exec.task;
	me == exec.object;
	
	meets(effect Position.Pos dest);
	dest.object == me.position;
	dest.from_task == true;
	dest.latitude == task.exit_latitude;
	dest.longitude == task.exit_longitude;
	
	
	starts(condition Position.Pos source);
	source.object == me.position;
	source.latitude == task.entry_latitude;
	source.longitude == task.entry_longitude;
	
	// compute the duration taking into account rounding error
	(dur_secs + 1.0) * exec.speed == exec.distance;
	
	duration >= dur_secs;
	start+duration == end;
}


